/**
 * @fileoverview Rule to prefer optional chaining over &&, || or ?. operators
 * @author GitHub Copilot
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Compares two member expressions to check if they represent the same property path
 * @param {ASTNode} expr1 First member expression
 * @param {ASTNode} expr2 Second member expression
 * @returns {boolean} True if the expressions are equivalent
 */
function areMemberExpressionsEqual(expr1, expr2) {
    if (expr1.type !== "MemberExpression" || expr2.type !== "MemberExpression") {
        return false;
    }

    /* Check if property parts match */
    if (expr1.computed !== expr2.computed) {
        return false;
    }

    if (expr1.computed) {
        /* For computed properties, we need to compare the property text */
        if (expr1.property.type !== expr2.property.type) {
            return false;
        }

        if (expr1.property.type === "Literal" && expr2.property.type === "Literal") {
            if (expr1.property.value !== expr2.property.value) {
                return false;
            }
        } else if (
            expr1.property.type === "Identifier" &&
            expr2.property.type === "Identifier"
        ) {
            if (expr1.property.name !== expr2.property.name) {
                return false;
            }
        } else {
            /* Different property expressions */
            return false;
        }
    } else {
        /* For dot notation, just compare the property names */
        if (
            expr1.property.type !== "Identifier" ||
            expr2.property.type !== "Identifier" ||
            expr1.property.name !== expr2.property.name
        ) {
            return false;
        }
    }

    /* Objects must match - either both identifiers with same name or both matching member expressions */
    if (expr1.object.type === "Identifier" && expr2.object.type === "Identifier") {
        return expr1.object.name === expr2.object.name;
    }

    if (expr1.object.type === "MemberExpression" && expr2.object.type === "MemberExpression") {
        return areMemberExpressionsEqual(expr1.object, expr2.object);
    }

    return false;
}

/**
 * Gets the root object of a member expression chain
 * @param {ASTNode} node The node to check
 * @returns {ASTNode} The root object node
 */
function getRootObject(node) {
    if (node.type !== "MemberExpression") {
        return node;
    }

    return getRootObject(node.object);
}

/**
 * Checks if a member expression is a parent of a call expression's callee
 * @param {ASTNode} calleeExpr The callee expression to check
 * @param {ASTNode} parentExpr The potential parent expression
 * @returns {boolean} True if parentExpr is a parent of calleeExpr
 */
function isParentOfCallExpression(calleeExpr, parentExpr) {
    if (calleeExpr.type !== "MemberExpression") {
        return false;
    }

    /* If they're the same expression */
    if (areMemberExpressionsEqual(calleeExpr, parentExpr)) {
        return true;
    }

    /* Check if parent is part of the call expression's object chain */
    if (calleeExpr.object.type === "MemberExpression") {
        return isParentOfCallExpression(calleeExpr.object, parentExpr);
    }

    return false;
}

/**
 * Checks if a member expression is part of a chain that starts with a base identifier
 * @param {ASTNode} expr The member expression to check
 * @param {ASTNode} base The base identifier node
 * @returns {boolean} True if the expression is part of a chain starting with base
 */
function isPartOfChain(expr, base) {
    if (expr.type !== "MemberExpression") {
        return false;
    }

    if (expr.object.type === "Identifier") {
        return expr.object.name === base.name;
    }

    if (expr.object.type === "MemberExpression") {
        return isPartOfChain(expr.object, base);
    }

    return false;
}

/**
 * Checks if the expression is a member expression with a matching base path
 * @param {ASTNode} expression The expression to check
 * @param {string|ASTNode} base The base identifier or expression to match against
 * @returns {boolean} True if it's a matching member expression
 */
function isMatchingMemberExpression(expression, base) {
    if (expression.type !== "MemberExpression") {
        return false;
    }

    // If base is a string, check if the object is an identifier with that name
    if (typeof base === "string") {
        return expression.object.type === "Identifier" && expression.object.name === base;
    }

    // If we're checking a nested path (foo.a matching against foo)
    if (base.type === "Identifier" && expression.object.type === "MemberExpression") {
        /* Recursively check if the object's chain starts with the base identifier */
        return isPartOfChain(expression.object, base);
    }

    // Check if the member expression's object matches the base
    if (base.type === "MemberExpression") {
        // Compare the two member expressions
        return areMemberExpressionsEqual(expression.object, base);
    }

    return false;
}

/**
 * Checks if the expression is a call expression with a matching base path
 * @param {ASTNode} expression The expression to check
 * @param {string|ASTNode} base The base identifier or expression to match against
 * @returns {boolean} True if it's a matching call expression
 */
function isMatchingCallExpression(expression, base) {
    if (expression.type !== "CallExpression") {
        return false;
    }

    // Simple case: foo && foo()
    if (typeof base === "string") {
        return expression.callee.type === "Identifier" && expression.callee.name === base;
    }

    // Handle method calls: foo.bar()
    if (expression.callee.type === "MemberExpression") {
        if (base.type === "Identifier") {
            // Check if the method call is on an object that matches the base identifier
            const rootObj = getRootObject(expression.callee);
            return rootObj.type === "Identifier" && rootObj.name === base.name;
        } else if (base.type === "MemberExpression") {
            // For nested chains: foo.a && foo.a.b()
            return isParentOfCallExpression(expression.callee, base);
        }
    }

    return false;
}

/**
 * Checks if a value is nullish (null or undefined)
 * @param {ASTNode} node The node to check
 * @returns {boolean} True if the node represents null or undefined
 */
function isNullish(node) {
	return (
		(node.type === "Literal" && node.value === null) ||
		(node.type === "Identifier" && node.name === "undefined")
	);
}

/**
 * Checks if we have a chain of logical expressions that form a nullish check
 * @param {ASTNode} node The node to check
 * @returns {{chain: ASTNode[], operator: string}|null} Object with chain info or null
 */
function findLogicalChain(node) {
    if (node.type !== "LogicalExpression") {
        return null;
    }

    const operator = node.operator;
    const chain = [node];

    // Recursively go through the right side to find the complete chain
    let current = node.right;
    while (current.type === "LogicalExpression" && current.operator === operator) {
        chain.push(current);
        current = current.right;
    }

    return { chain, operator };
}

/**
 * Extracts the property path from a member expression
 * @param {ASTNode} memberExpr The member expression
 * @returns {string} The property path
 */
function extractPropertyPath(memberExpr) {
    if (memberExpr.type !== "MemberExpression") {
        return "";
    }

    // Skip the base part (we only need properties)
    if (memberExpr.object.type === "Identifier") {
        const computed = memberExpr.computed;
        const prop = memberExpr.property.name || memberExpr.property.value;
        return computed ? `[${prop}]` : `.${prop}`;
    }

    if (memberExpr.object.type === "MemberExpression") {
        const prefix = extractPropertyPath(memberExpr.object);
        const computed = memberExpr.computed;
        const prop = memberExpr.property.name || memberExpr.property.value;
        return prefix + (computed ? `[${prop}]` : `.${prop}`);
    }

    return "";
}

/**
 * Builds an optional chain path from a negated OR chain
 * @param {Array} expressions The array of logical expressions
 * @returns {string} The chained property path
 */
function buildChainFromNegatedOR(expressions) {
    let result = "";

    for (let i = 1; i < expressions.length; i++) {
        const expr = expressions[i];
        if (expr.right.type !== "UnaryExpression" || expr.right.operator !== "!") {
            continue;
        }

        const arg = expr.right.argument;
        if (arg.type === "MemberExpression") {
            // Extract the property path beyond the base object
            const propPath = extractPropertyPath(arg);
            result += propPath;
        }
    }

    return result;
}

/**
 * Checks if a logical chain represents an optional chain candidate
 * foo && foo.a && foo.a.b
 * @param {Array} chain Array of nodes in the logical chain
 * @param {string} operator The logical operator ('&&' or '||')
 * @returns {boolean} True if the chain can be converted to optional chaining
 */
function isChainableLogicalExpression(chain, operator) {
    // Need at least two expressions for a chain
    if (chain.length < 1) {
        return false;
    }

    const firstNode = chain[0];

    // For AND chains (&&)
    if (operator === "&&") {
        // Get the identifier or expression from the left side
        let base = firstNode.left;

        // For complex base expressions, try to find the root identifier
        if (base.type === "MemberExpression") {
            base = getRootObject(base);
        }

        // Only proceed if we have an identifier as base
        if (base.type !== "Identifier") {
            return false;
        }

        // Check if each right part correctly extends the chain
        let current = base;
        for (const expr of chain) {
            const next = expr.right;

            // Next part must be a member access or call on the current path
            if (next.type === "MemberExpression") {
                const nextRoot = getRootObject(next);

                if (current.type === "Identifier") {
                    /* If current is identifier, next root must match it */
                    if (nextRoot.type !== "Identifier" || nextRoot.name !== current.name) {
                        return false;
                    }
                } else if (current.type === "MemberExpression") {
                    /* If current is member expression, next must extend it */
                    /* This is a simplified check that could be improved */
                    const currentRoot = getRootObject(current);
                    if (nextRoot.type !== "Identifier" || nextRoot.name !== currentRoot.name) {
                        return false;
                    }
                } else {
                    return false;
                }
            } else if (next.type === "CallExpression") {
                /* For method calls */
                if (next.callee.type === "MemberExpression") {
                    const nextRoot = getRootObject(next.callee);
                    if (current.type === "Identifier") {
                        if (nextRoot.type !== "Identifier" || nextRoot.name !== current.name) {
                            return false;
                        }
                    }
                } else if (next.callee.type === "Identifier") {
                    if (current.type !== "Identifier" || next.callee.name !== current.name) {
                        return false;
                    }
                } else {
                    return false;
                }
            } else if (next.type === "BinaryExpression" &&
                      (next.operator === "!=" || next.operator === "!==") &&
                      (next.left.type === "MemberExpression" || next.right.type === "MemberExpression")) {
                /* Handle strict nullish checks: foo.a != null */
                /* This is a simplified check that could be improved */
                return true;
            } else {
                return false;
            }

            /* Update current to the right part for next iteration */
            current = next;
        }

        return true;
    }

    // For OR chains with empty objects (foo || {})
    if (operator === "||") {
        // Check for negated OR patterns: !foo || !foo.bar
        if (firstNode.left.type === "UnaryExpression" && firstNode.left.operator === "!") {
            const baseExpr = firstNode.left.argument;
            if (baseExpr.type !== "Identifier") {
                return false;
            }

            const baseName = baseExpr.name;

            /* Check if each subsequent expression is a negation of a property access */
            for (const expr of chain) {
                if (expr.right.type !== "UnaryExpression" || expr.right.operator !== "!") {
                    return false;
                }

                const rightArg = expr.right.argument;
                if (rightArg.type === "MemberExpression") {
                    const rootObj = getRootObject(rightArg);
                    if (rootObj.type !== "Identifier" || rootObj.name !== baseName) {
                        return false;
                    }
                } else {
                    return false;
                }
            }

            return true;
        }

        /* Check for OR patterns with empty object fallbacks: (foo || {}).prop */
        /* This is a simplified check - full implementation would need to ensure */
        /* the entire pattern matches (((foo || {}).a || {}).b || {}).c */
        if (firstNode.left.type === "Identifier" &&
            firstNode.right.type === "ObjectExpression" &&
            firstNode.right.properties.length === 0) {
            return true;
        }
    }

    return false;
}

/**
 * Determines whether a node is a nullish check (using && or != null)
 * @param {ASTNode} node The node to check
 * @returns {boolean} `true` if the node is a nullish check
 */
function isNullishCheck(node) {
    /* Check for logical expressions chains (&&, ||) */
    if (node.type === "LogicalExpression") {
        const chain = findLogicalChain(node);
        if (chain && isChainableLogicalExpression(chain.chain, chain.operator)) {
            return true;
        }

        // Simple case for && operator
        if (node.operator === "&&") {
            // Skip non-identifier left sides
            if (node.left.type !== "Identifier") {
                // Valid cases: obj.prop && obj.prop.subprop, a && a.b.c
                if (node.left.type === "MemberExpression") {
                    if (node.right.type === "MemberExpression") {
                        // Don't consider different property paths like obj.prop && obj.other.prop
                        const leftRoot = getRootObject(node.left);
                        const rightRoot = getRootObject(node.right);

                        // Different root objects, can't be optional chained
                        if (
                            leftRoot.type !== rightRoot.type ||
                            leftRoot.name !== rightRoot.name
                        ) {
                            return false;
                        }

                        /* For now, skip complex paths, they'll be handled in the chain logic above */
                        return false;
                    }
                }
                return false;
            }

            const identifierName = node.left.name;

            // Check for obj && obj.prop or obj && obj[key] or obj && obj()
            return (
                isMatchingMemberExpression(node.right, identifierName) ||
                isMatchingCallExpression(node.right, identifierName)
            );
        }
    }

	if (node.type === "ConditionalExpression") {
		// Handle obj != null ? obj.prop : undefined pattern
		if (
			node.test.type !== "BinaryExpression" ||
			(node.test.operator !== "!=" && node.test.operator !== "!==") ||
			node.alternate.type !== "Identifier" ||
			node.alternate.name !== "undefined"
		) {
			return false;
		}

		const { left, right } = node.test;
		let identifier;

		// Find which side is the identifier and ensure the other is a nullish value
		if (left.type === "Identifier" && isNullish(right)) {
			identifier = left;
		} else if (right.type === "Identifier" && isNullish(left)) {
			identifier = right;
		} else {
			return false;
		}

		// Ensure consequent is a property/method call on the same identifier
		if (node.consequent.type === "MemberExpression") {
			return isMatchingMemberExpression(node.consequent, identifier.name);
		}
		if (node.consequent.type === "CallExpression") {
			return isMatchingCallExpression(node.consequent, identifier.name);
		}
	}

	return false;
}

/**
 * Gets the expression from an if statement's consequent body
 * @param {ASTNode} node The if statement node
 * @returns {ASTNode|null} The expression node or null
 */
function getExpressionFromIfConsequent(node) {
	if (node.consequent.type === "ExpressionStatement") {
		return node.consequent.expression;
	}
	if (
		node.consequent.type === "BlockStatement" &&
		node.consequent.body.length === 1 &&
		node.consequent.body[0].type === "ExpressionStatement"
	) {
		return node.consequent.body[0].expression;
	}

	return null;
}

/**
 * Determines whether a node is a conditional check using if statements
 * @param {ASTNode} node The node to check
 * @returns {boolean} `true` if the node is an if statement with a nullish check
 */
function isIfStatementNullishCheck(node) {
	if (node.type !== "IfStatement" || node.test.type !== "Identifier") {
		return false;
	}

	const identifierName = node.test.name;
	const expression = getExpressionFromIfConsequent(node);

	if (!expression) {
		return false;
	}

	// Check if the if statement follows the pattern if(obj) obj.prop or if(obj) obj()
	return (
		isMatchingMemberExpression(expression, identifierName) ||
		isMatchingCallExpression(expression, identifierName)
	);
}

/**
 * Creates a fixer that replaces a logical expression with optional chaining
 * @param {ASTNode} node The node to be fixed
 * @param {SourceCode} sourceCode The source code object
 * @returns {Function} Fixer function
 */
function createFixer(node, sourceCode) {
	/**
	 * Generates the optional chain syntax for a member expression
	 * @param {string} base The base identifier
	 * @param {ASTNode} memberExpr The member expression
	 * @param {Object} fixer The fixer object
	 * @returns {Object} Fix command
	 */
	function fixMemberExpression(base, memberExpr, fixer) {
		const computed = memberExpr.computed;
		const property =
			memberExpr.property.name || sourceCode.getText(memberExpr.property);

		if (computed) {
			return fixer.replaceText(
				node,
				`${base}?.[${property}]${node.type === "IfStatement" ? ";" : ""}`,
			);
		}
		return fixer.replaceText(
			node,
			`${base}?.${property}${node.type === "IfStatement" ? ";" : ""}`,
		);
	}

	/**
	 * Generates the optional chain syntax for a call expression
	 * @param {string} base The base identifier
	 * @param {ASTNode} callExpr The call expression
	 * @param {Object} fixer The fixer object
	 * @returns {Object} Fix command
	 */
	function fixCallExpression(base, callExpr, fixer) {
		const callText = sourceCode.getText(callExpr);
		const callArgs = callText.slice(callText.indexOf("("));
		return fixer.replaceText(
			node,
			`${base}?.${callArgs}${node.type === "IfStatement" ? ";" : ""}`,
		);
	}

    /**
     * Generates the optional chain syntax for a complex nested chain
     * @param {ASTNode} chainNode The logical expression chain node
     * @param {Object} fixer The fixer object
     * @returns {Object} Fix command
     */
    function fixComplexChain(chainNode, fixer) {
        const chain = findLogicalChain(chainNode);
        if (!chain) {
            return null;
        }

        const { chain: expressions, operator } = chain;

        // Handle AND chains (foo && foo.a && foo.a.b && foo.a.b.c)
        if (operator === "&&") {
            const firstNode = expressions[0];
            const baseIdentifier =
                firstNode.left.type === "Identifier"
                    ? firstNode.left.name
                    : sourceCode.getText(getRootObject(firstNode.left));

            // Build the chain by extracting property names
            let result = baseIdentifier;
            let lastProcessed = null;

            // Process all nodes in the chain
            for (let i = 0; i < expressions.length; i++) {
                const expr = expressions[i];
                const right = expr.right;

                if (right.type === "MemberExpression") {
                    // Handle member access
                    const computed = right.computed;
                    const prop = right.property.name || sourceCode.getText(right.property);

                    if (i === 0) {
                        // First access needs the ?. operator
                        result += computed ? `?.[${prop}]` : `?.${prop}`;
                    } else {
                        // Subsequent properties in the same chain
                        result += computed ? `.[${prop}]` : `.${prop}`;
                    }
                } else if (right.type === "CallExpression") {
                    // Handle method calls
                    if (right.callee.type === "MemberExpression") {
                        const memberCallee = right.callee;
                        const computed = memberCallee.computed;
                        const prop = memberCallee.property.name || sourceCode.getText(memberCallee.property);

                        if (i === 0) {
                            // First access needs the ?. operator
                            result += computed ? `?.[${prop}]` : `?.${prop}`;
                        } else {
                            // Subsequent properties in the same chain
                            result += computed ? `.[${prop}]` : `.${prop}`;
                        }

                        // Add the function call arguments
                        const callText = sourceCode.getText(right);
                        result += callText.slice(callText.indexOf("("));
                    } else {
                        // Direct function call
                        const callText = sourceCode.getText(right);
                        result += `?.${callText.slice(callText.indexOf("("))}`;
                    }
                }

                lastProcessed = expr;
            }

            return fixer.replaceText(chainNode, result);
        }

        // Handle negated OR patterns (!foo || !foo.bar)
        if (operator === "||" &&
            expressions[0].left.type === "UnaryExpression" &&
            expressions[0].left.operator === "!") {

            const baseArg = expressions[0].left.argument;
            if (baseArg.type !== "Identifier") {
                return null;
            }

            // Create a negated optional chain
            return fixer.replaceText(chainNode, `!${baseArg.name}?.${buildChainFromNegatedOR(expressions)}`);
        }

        return null;
    }

	return function (fixer) {
        // Check for complex chains
        const chain = findLogicalChain(node);
        if (chain && chain.chain.length > 0) {
            const complexFix = fixComplexChain(node, fixer);
            if (complexFix) {
                return complexFix;
            }
        }

		// Handle logical AND expressions: obj && obj.prop
		if (node.type === "LogicalExpression" && node.operator === "&&") {
			const base = sourceCode.getText(node.left);

			if (node.right.type === "MemberExpression") {
				return fixMemberExpression(base, node.right, fixer);
			}
			if (node.right.type === "CallExpression") {
				return fixCallExpression(base, node.right, fixer);
			}
		}
		// Handle conditional expressions: obj != null ? obj.prop : undefined
		else if (node.type === "ConditionalExpression") {
			const base =
				node.test.left.type === "Identifier"
					? node.test.left.name
					: node.test.right.name;

			if (node.consequent.type === "MemberExpression") {
				return fixMemberExpression(base, node.consequent, fixer);
			}
			if (node.consequent.type === "CallExpression") {
				return fixCallExpression(base, node.consequent, fixer);
			}
		}
		// Handle if statements: if (obj) obj.prop
		else if (node.type === "IfStatement") {
			const base = sourceCode.getText(node.test);
			const expression = getExpressionFromIfConsequent(node);

			if (expression.type === "MemberExpression") {
				return fixMemberExpression(base, expression, fixer);
			}
			if (expression.type === "CallExpression") {
				return fixCallExpression(base, expression, fixer);
			}
		}

		return null;
	};
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule} */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Require using optional chaining instead of &&, || or ternary operators",
			recommended: false,
			frozen: true,
			url: "https://eslint.org/docs/latest/rules/prefer-optional-chaining",
		},

		schema: [],
		fixable: "code",

		messages: {
			preferOptionalChain:
				"Use optional chaining '?.' instead of logical chaining.",
		},
	},

	create(context) {
		const sourceCode = context.sourceCode;

		return {
			LogicalExpression(node) {
				if (isNullishCheck(node)) {
					context.report({
						node,
						messageId: "preferOptionalChain",
						fix: createFixer(node, sourceCode),
					});
				}
			},
			ConditionalExpression(node) {
				if (isNullishCheck(node)) {
					context.report({
						node,
						messageId: "preferOptionalChain",
						fix: createFixer(node, sourceCode),
					});
				}
			},
			IfStatement(node) {
				if (isIfStatementNullishCheck(node)) {
					context.report({
						node,
						messageId: "preferOptionalChain",
						fix: createFixer(node, sourceCode),
					});
				}
			},
		};
	},
};
