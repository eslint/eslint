"use strict";

const https = require("node:https");
const fs = require("node:fs");
const path = require("node:path");
const readline = require("node:readline");

const SOURCE_URL =
	"https://www.unicode.org/Public/UCD/latest/ucd/extracted/DerivedGeneralCategory.txt";

const OUTPUT_FILE = path.join(
	__dirname,
	"../lib/rules/utils/unicode/combining-ranges.generated.js",
);

/**
 * Downloads the Unicode data from the given URL.
 * @param {string} url The URL to download the Unicode data from.
 * @returns {Promise<NodeJS.ReadableStream>} A promise that resolves to the readable stream of the Unicode data.
 */
function download(url) {
	return new Promise((resolve, reject) => {
		https
			.get(url, res => {
				if (res.statusCode !== 200) {
					reject(
						new Error(
							`Failed to download Unicode data: ${res.statusCode}`,
						),
					);
					return;
				}
				resolve(res);
			})
			.on("error", reject);
	});
}

/**
 * Generates the combining-ranges.generated.json file.
 * @returns {Promise<void>}
 */
async function generate() {
	console.log(`Fetching Unicode data:\n${SOURCE_URL}`);

	const stream = await download(SOURCE_URL);
	const rl = readline.createInterface({ input: stream });

	const codePoints = [];

	for await (const line of rl) {
		const trimmed = line.trim();
		if (!trimmed || trimmed.startsWith("#")) {
			continue;
		}

		// Format: <range> ; <category> # ...
		const [rangePart, rest] = trimmed.split(";");
		if (!rest) {
			continue;
		}

		const category = rest.trim().split(/\s+/u)[0];
		if (category !== "Mn" && category !== "Mc" && category !== "Me") {
			continue;
		}

		const range = rangePart.trim();
		if (range.includes("..")) {
			const [start, end] = range.split("..").map(h => parseInt(h, 16));
			for (let cp = start; cp <= end; cp++) {
				codePoints.push(cp);
			}
		} else {
			codePoints.push(parseInt(range, 16));
		}
	}

	// Sort code points
	codePoints.sort((a, b) => a - b);

	// Collapse into minimal ranges
	const ranges = [];
	let start = null;
	let prev = null;

	for (const cp of codePoints) {
		if (start === null) {
			start = cp;
			prev = cp;
		} else if (cp === prev + 1) {
			prev = cp;
		} else {
			ranges.push([start, prev]);
			start = cp;
			prev = cp;
		}
	}
	if (start !== null) {
		ranges.push([start, prev]);
	}

	// Emit JS module
	const out = [];
	out.push(`"use strict";`);
	out.push(`/*`);
	out.push(
		` * WARNING: This file is autogenerated using the tools/generate-combining-ranges.js script. Do not edit manually.`,
	);
	out.push(` * Source: ${SOURCE_URL}`);
	out.push(` * Unicode categories: Mn, Mc, Me`);
	out.push(` */`);

	out.push(`module.exports = Object.freeze([`);

	for (const [s, e] of ranges) {
		out.push(`  [0x${s.toString(16)}, 0x${e.toString(16)}],`);
	}

	out.push(`]);`);

	fs.writeFileSync(OUTPUT_FILE, out.join("\n"));
	console.log(`Generated ${OUTPUT_FILE}`);
}

generate().catch(err => {
	console.error(err);
	process.exit(1);
});
